const crypto = require('crypto'); //importing Node.js crypto module as the below functions use crypto-specific JS methods

//QUESTION 6: return4RandomColors MODIFY
const numsToRGBColor = ([color1, color2, color3]) => { //wrapping passed in values into an arr that is destructured where each el is given a var name, color#
  return `rgb(${color1}, ${color2}, ${color3})`; //returning a str of one single RGB color (RGBs are composed of three colors that make up one final color). using str interpolation, included the 3 color# vars of the passed in vals (can now assume that the passed in values will be ints ranging from 0 to 255)
};

/* deciphering the callback hell function below (renamed from get4RandomColors):
crypto.randomFill is a Node.js 'crypto' module method that generates random numbers as bytes to fill a buffer/TypedArray. below, it is invoked with two parameters: (1) a Uint8Array (a subclass of TypedArrays, which is a subclass of ArrayBufferView) and (2) a callback function (err1, buffer1)
(1) invoked here, the crypto method will fill in random bytes into a newly constructed Uint8Array with a length property of 3 (representing 3 el slots to be filled in with RGB color values)- to elaborate, each el in the arr holds an 8-bit int represented by its decimal value (ranging from 0 to 255); meaning that the random ints filled in will range from 0 to 255, and in this case, represent RGB values
(2) next, invoked on the 2nd is a callback function that receives an error object (err1) and the just filled Uint8Array (buffer1). buffer1 is the same instance as the original Uint8Array, passed by reference, sharing the same location in memory
note: a Buffer in js (not the same thing as buffer1 here) represents a space in memory, like RAM, that stores a sequence of raw binary data + allows us to perform operations on it; it provides a way to handle raw binary data directly in memory. though not the same, both a Buffer and buffer1 serve similar purposes in handling binary data
*/

const get4CallbackHell = (useColorsCallback) => { //this param is for an outside func to be able to use the colors generated by this function
  const colors = []; //a new arr of rgb color str els (should be 4 random colors in the end)
  crypto.randomFill(new Uint8Array(3), (err1, buffer1) => { //generating an arr of 3 random rgb color values representing one single color
    if (err1) throw new Error(err1); //error handler for the 2nd param callback func; i can see how this is callback hell- hard to tell where it ends as it keeps taking in more callbacks in the later lines of code
    colors.push(numsToRGBColor([...buffer1])); //pushing resulting data into the new colors arr --> first invoked numsToRGBColor func on the spread of buffer1 (used spread operator on buffer1 to convert buffer1's arr values from byte data ints into usable int values)- this invocation produces a str --> 'rgb(buffer1Color1, buffer1Color2, buffer1Color3)'

    crypto.randomFill(new Uint8Array(3), (err2, buffer2) => { //same as above, now generating the second random rgb color
      if (err2) throw new Error(err2);
      colors.push(numsToRGBColor([...buffer2]));

      crypto.randomFill(new Uint8Array(3), (err3, buffer3) => { //3rd random rgb color
        if (err3) throw new Error(err3);
        colors.push(numsToRGBColor([...buffer3]));

        crypto.randomFill(new Uint8Array(3), (err4, buffer4) => { //4th random rgb color
          if (err4) throw new Error(err4);
          colors.push(numsToRGBColor([...buffer4]));

          useColorsCallback(colors); //invoking whatever callback func is passed into the parameter with the colors arr we just completed, consisting of 4 strs, each with a random rgb color
        });
      });
    });
  });
};

//logging this to the console for better understanding
const callback4Callback = (colors) => console.log(typeof 'colors:', typeof colors); //logs whatever val is passed in the param with a str
get4CallbackHell(callback4Callback); //will log a str and an arr of 4 random rgb colors as strs

const getRandomBytes = () => new Promise((resolve, reject) => { //creates a reusable asynchronous function using new Promise constructor to generate random bytes representing rgb colors, like the func above
  crypto.randomFill(new Uint8Array(3), (err, buffer) => {
    if (err) return reject(err);
    resolve([...buffer]); //resolves with an array containing 3 random bytes as RGB color integers- does this by using the spread operator on buffer to convert the buffer's byte data into usable int values for subsequent promise chaining and .then() propagation in the func below
  });
});

const return4RandomColors = () => {
  const colors = [];
  return getRandomBytes() //initiates the promise chain by getting the first set of random rgb colors from the resolve([...buffer])
    .then((color1) => { //storing the results from the invocation of getRandomBytes() above in the param as color1, where color1 is again the random set of rgb colors from the code statement above
      colors.push(numsToRGBColor(color1)); //pushing the invocation of numsToRGBColor on color1 to the new colors arr (the numeric values in color1 was converted to an rgb str)
      return getRandomBytes(); //returning the resolve() data, getting another set of 3 random rgb ints to continue the promise chain, passing it into the next .then() 
    })
    .then((color2) => {
      colors.push(numsToRGBColor(color2)); //again, pushing the rbg color str into the new arr, colors- which we'll return in the last .then() chain
      return getRandomBytes();
    })
    .then((color3) => {
      colors.push(numsToRGBColor(color3));
      return getRandomBytes();
    })
    .then((color4) => {
      colors.push(numsToRGBColor(color4));
      return colors; //returning the final colors arr that now has 4 random rgb color strs
    })
    .catch((err) => {
      console.error(`Error encountered: ${err} ${err.message}`); //handles any errors that occur during the promise chain, logging the error and a message for troubleshooting
  });
};

return4RandomColors().then(console.log); //logs the array with 4 random rgb color strs like --> [ 'rgb(105, 178, 206)', 'rgb(227, 181, 154)', ... ]

module.exports = {
  numsToRGBColor,
  getRandomBytes,
  return4RandomColors,
};